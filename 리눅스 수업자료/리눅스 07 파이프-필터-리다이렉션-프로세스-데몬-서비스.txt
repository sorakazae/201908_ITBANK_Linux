파이프(pipe) : 두 프로그램을 연결해 주는 연결 통로의 의미
"|" 문자를 사용함
사용 예
ls -l /etc | more
그냥 ls -l /etc 명령을 입력하면 파일이 너무 많아서, 페이지가 넘어가므로 한 개 페이지씩 보겠다는 의미
ps
필터(filter) 필요한 것만 걸러주는 명령어

grep, tail, wc, sort, awk, sed등
[사용 예]
ps -ef | grep bash
:그냥 ps -ef는 모든 프로세스 번호를 출력하므로, "bash" 라는 글자가 들어간 프로세스만 출력
rpm -qa | grep bind
설치된 패기지 중에서 "bind" 라는 글자가 들어간 패키지를 출력
그냥 "rpm -qa bindls "를 할 경우에는 "bind-utils"는 출력되지 않음

리다이렉션(redirection) 표준 입출력의 방향을 바꿔줌
표준 입력은 키보드, 표준출력은 모니터이지만 이를 파일로 처리하고 싶을 때 사용
<사용 예>
ls -l > aa.lst
: ls -l의 결과를 화면에 출력하지 않고 aa.lst 라는 파일에 쓰도록 한다. 단 aa.lst 파일이 있으면 덮어 쓴다.

ls -l >> aa.lst
위와 동일. 단 aa.lst 파일이 기존에 있으면 기존의 내용에 이어서 씀

sort < aa.lst
aa.lst 파일을 정렬해서 화면에 출력한다.
sort < aa.lst > bb.lst
aa.lst 파일을 정렬해서, bb.lst 파일에 쓴다.

♣ 프로세스
프로세스(Procoss)를 간단히 정의하자면 "하드디스크에 저장된 실행 코드(프로그램)가 메모리에 로딩되어 활성화된것"이라고 할 수 있다.
1. 포그라운드 프로세스 
Firefox 등과 같이 실행하면 화면에 나타나서 사용자와 상호 작용을 하는 프로세스를 말한다. 화면에서 실행되는 것이 보이는 프로세스라고 생각하면 된다.

2. 백그라운드 프로세스
실행은 되었지만 화면에서 나타나지 않고 뒤에서 실행되는 프로세스를 말한다. 예를 들어 바이러스 백신, 서버 데몬 등은 눈에는 보이지 않지만 실행되고 있는 것이다.
3. 프로세스 번호
메모리에 로딩되어 할성화된 프로세스를 구분하기 위해서는 각각의 고유 번호가 필요하다. 이렇게 각각의 프로세스에 할당된 고유 번호를 프로세스 번호라 부른다. 프로세스 번호가 필요한 이유는 메모리에서 활성화된 프로세스를 메모리에서 강제적으로 퇴장 시키기 위해서는 프로세스 번호를 사용해야 하기 때문이다
4. 작업 번호 : 현재 실행되고 있는 백그라운드 프로세스의 순차 번호를 의미한다.

5, 부모 프로세스와 자식 프로세스
모든 프로세스는 혼자서 독립적으로 실행되는 것이 아니라, 부모 프로세스의 하위에 종속되어 실행된다,
관련 명령어
1. ps 
현재 프로세스의 상태를 확인 하는 명령어로 많은 옵션과 함께 사용할 수 있다. 이 책에서 프로세스의 번호 및 상태를 확인할 때 주로 사용하게 될 명령은 ps -ef : grep <프로세스 이름>이다

2. kill
프로세스를 강제로 종료하는 명령어로 "-9" 옵션가 함께 사용하면 무조건 프로세스가 종료된다
kill -9 <프로세스 번호>

3. pstree
부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여준다

실습문제 포그라운와 백그라운드 프로세스
1. 무한 루프를 도는 프로세스를 중지해 본다
1. yes > /dev/null 명령으로 루프를 도는 단순한 프로세스 생성
2. 터미널을 하나 열고 ps -ef : grep yes 프로세스 번호를 확인 한다.
 /dev/null 은 특수한 장치파일로 모든 입력을 (마치 블랙홀 마냥) 없애버립니다.
root 20697   24361   
root는 소유주 20697 프로세스 번호 24361 부모 프로세스 번호
kill -9 <프로세스번호>로 종료

2. 포그라운드 프로세스 -> 백그라운드 프로세스->포그라운드 프로세스의 상황을 바꿔보자
1. yes > /dev/null 무한 루프 생성
2. ctrl+z 눌러서 프로세스를 일시 중지 시키고, bg 명령을 입력해서 잠시 중지된 프로세스를 백그라운드로 프로세스로 계속 실행 시킨다.
yes > /dev/null
ctrl + z
bg
[1] + yes > /dev/null & 
3. jobs 명령을 입력하면 현재 백그라운드로 가동중인 작업을 확인할 수 있다 제일 앞에 나오는 것이 작업 번호이다 "fg <작업번호>" 명령으로 다시 포그라운드 프로세스를 만든다.
jobs
1 + running /dev/null
fg 1
ctrl + c 눌러서 프로세스 종료
4. gedit로 명령어로 데이터를 실행한다. 그런데 gedit로 실행한 터미널은 더 이상 사용할 수 없다
gedit
종료
gedit & 명령 입력 -> 터미널을 계속 사용할 수 있다, 명령어 뒤에 &를 붙인다는 것은 백그라운드 프로세스로 실행 하겠다는 의미다,

♣ 데몬

서비스(Service) 라고도 부르는 데몬(daemon)은 서버 프로세스를 말한다. 즉 웹서버, 네임서버, DB 서버 등의 프로세스를 지칭해서 데몬이라고 부른다. 다르게는 웹 서버 데몬, 네임 서버 데몬 등으로 부르기도 한다.
데몬은 눈에 보이지는 않지만, 현재 시스템에서 활동 중인 프로세스므로 백그라운드 프로세스의 일종이라고 할수 있다.
데몬=서비스=서버 프로세스 정도로 이해


♣ 서버 데몬의 유형

서버 데몬은 Standalone 타입의 데몬과 xinetd 타입의 데몬으로 나뉜다 
- Standalone 타입의 데몬 설명
-시스템에 독자적으로 프로세스가 구동되어 서비스를 제공하는 데몬을 말한다. 예로 웹서버(httpd), DB 서버(my-sql), 샌드메일 서버(sendmail) 등이 있다.
- 실행 및 종료는 대개 service 데몬 이름 start/stop/restart로 사용한다. 예로 NFS 서버는 "service nfs start" 명령으로 구동한다.
-standalone 타입 데몬의 실행 스크립트 파일은 /etc/init.d/ 디렉토리에 주로 들어 있다. 단 이 디렉토리에 있다고 전부 데몬이라고 애기하지는 않는다.
이 디렉토리에 있는 파일들은 대개 service 서비스 이름 [실행 옵션]으로 실행이 가능하다. 또한 /etc/init.d/서비스 이름 [실행옵션]으로 실행하는 것과 동일하다. 즉 'service nfs restart' 명령이나 /etc/init.d/nfs restart 명령은 동일한 명령이다.

-/etc/init.d/ 디렉토리의 실행 스크립트(standalone 타입의 데몬)는 부팅 시에 자동실행 여부를 지정할 수 있다. system-config-services 명령으로 /etc/init.d/ 디렉토리의 파일 목록과 왼쪽의 서비스 목록 창과 일치함을 확인할 수 있다.

-메모리상에 항상 구동되어야 하기 때문에 자주 호출되는 서비스(데몬)는 standalone 타입의 데몬으로 사용하기에 적당하다. 예로 웹 서버 데몬, 삼바 서버 데몬 등을 들 수 있다. 하지만 가끔 사용되는 서비스(데몬)를 standalone 타입의 데몬으로 사용하면 사용되지 않는 시간에도 항상 메모리상에 구동되어 있으므로 시스템 자원의 낭비를 가져온다.


- xinetd 타입의 데몬 설명
-xinted 데몬은 일명 수퍼 데몬 이라고도 부른다. 수퍼(Super)의 의미는 다른 데몬의 상위에 존재한다는 뜻으로, xinted 데몬은 다른 하위의 데몬을 지배하는 상위 데몬이다.

-주의할 점이 있는데, xineted 데몬과 xinted 타입의 데몬은 다르다. xinted 데몬 자체는 standalone 타입의 데몬으로 항상 프로세스가 구성되어 있다.

-xinted 데몬 자체는 항상 가동 되고 있지만 , xinted 데몬이 하는 역활은 자신이 직접 서비스를 하지 않고, 외부에서 특정 서비스 요쳥할 경우에 자신에게 종속된 하위 데몬(이를 xinted 타입의 데몬 이라 부름)을 구동시킨 후에 그 데몬이 서비스르 하도록 연결시켜주는 것이다. 그리고 서비스 요쳥이 종료되면 구동되었던 하위 데몬도 자동으로 종료된다.

그래서 xinted 데몬과 관련된 서비스를 요쳥 시에는 처음 연결 되는 시간이 standalone 타입의 데몬에 비해서 약간 더 걸릴 수 있다. 왜야하면 xinted 데몬이 서비스르 수행하는 하위 데몬을 새로이 구동하기 위한 시간이 소요되기 떄문이다. 대표적인 예로 텔넷 서버를 들 수 있다.

- xinetd 타입의 데몬으로 사용하기 적당한 데몬은 가끔 사용되는 데몬이다. 가끔 사용되는 데몬을 항상 메모리에 구동시켜 놓는다면 자원의 낭비를 초래하기 때문이다. 하지만 자주 사용되는 데몬은 xinetd 타입의 데몬으로 설정해 놓는다면 데몬을 구동하고 종료 하는 것을 게속 반복해야 하므로 오히려 시스템에 부담을 줘 서비스 속도가 현저히 느려질 수 있다.
그래서 FTP 서버의 경우에는 서버가 FTP 서버를 주용도로 사용할 때는 standalone 타입의 데몬으로, 그렇지 않고 FTP 서비스를 가끔 할 경우에는 xinetd 타입의 데몬으로 설정을 변경할 수 있다.








